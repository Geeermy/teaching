# -*- coding: utf-8 -*-
"""Clase 2 - Actividad - Solución.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1psbk27NzA7tnbdOC2twZeJuWfDRjPUin

# Diplomado en Big Data - Introducción a las Herramientas de la Nube

### **Profesor:** Germán Leandro Contreras Sagredo
### **Ayudantes**
### Jorge Becerra de la Torre
### Valentina Rojas Mercier

## Actividad de la Clase 2: Asignación de roles y manejo de recursos en S3

La empresa chilena *YesIndustry* ha logrado un alto estatus a nivel mundial, sobre todo el último tiempo, al ser pionera en el desarrollo de tecnología para la innovación de la industria alimentaria. Es más, ha sido recientemente nombrada una compañía *unicornio* al ser valorada en más de un millón de dólares gracias a sus últimas rondas de financiamiento.

En esta empresa, existen las siguientes áreas:

**1. Ingeniería de Software:** Área dedicada al desarrollo de las tecnologías utilizadas por la empresa.

**2. Ciencia de los alimentos:** Área encargada del estudio de recetas de los alimentos ofrecidos.

**3. Comercial:** Área encargada de la venta y distribución de productos alimenticios en los distintos mercados del país, así como también del financiamiento de los empleados de la empresa.

**4. Operaciones:** Área encargada de la gestión de recursos físicos de la empresa, como proveedores de insumos y alimentos.

*YesIndustry* ha escalado rápidamente en los últimos años dado su gran éxito, por lo que han decidido utilizar los servicios de Amazon Web Services para realizar sus actividades. Particularmente, almacenan grandes volúmenes de datos en S3 y, para cada área, existen recursos específicos a los que puede acceder cada una de ellas.

En esta actividad, deberás crear roles IAM dependiendo de las actividades que lleva a cabo cada una de las áreas mencionadas y, posteriormente, asignarle las políticas pertinentes para realizarlas. Al final de este *notebook* encontrarás una celda a ejecutar que tendrá el *output* esperado donde, rellenando con el nombre de cada rol que creaste, podrás *testear* si cada uno de ellos es efectivamente capaz de acceder a los recursos que le corresponde (y por supuesto, se le es denegado descargar aquellos en los cuales no debería tener permisos).

A continuación te entregamos algunas funciones para facilitar tu trabajo.

## FUNCIONES A UTILIZAR
"""

# Primero, instalamos las librerías necesarias
!pip install boto3
import json
import logging
import boto3
from botocore.exceptions import ClientError

# A continuación, definiremos en variables las distintas constantes a utilizar

# Credenciales de tu cuenta de AWS
AWS_ACCESS_KEY_ID = ''
AWS_SECRET_ACCESS_KEY = ''

# Nombre de los 4 buckets asociados a cada área
SOFTWARE_ENGINEER_BUCKET_NAME = 'software-engineer-files'
FOOD_SCIENCE_BUCKET_NAME = 'food-science-files'
COMMERCIAL_BUCKET_NAME = 'commercial-files'
OPERATIONS_BUCKET_NAME = 'operations-area-files'

# Links a los archivos asociados a cada área
SOFTWARE_ENGINEER_FILE_LINK =  'https://images.unsplash.com/flagged/photo-1558963675-94dc9c4a66a9?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=1000&q=80'
FOOD_SCIENCE_FILE_LINK =  'https://images.unsplash.com/photo-1600132806608-231446b2e7af?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=1000&q=80'
COMMERCIAL_FILE_LINK =  'https://images.unsplash.com/photo-1562240020-ce31ccb0fa7d?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=1000&q=80'
OPERATIONS_FILE_LINK =  'https://images.unsplash.com/photo-1583521214690-73421a1829a9?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1000&q=80'

# Nombre de los archivos asociados a cada área
SOFTWARE_ENGINEER_FILE_NAME =  'Funcionalidades a implementar.png'
FOOD_SCIENCE_FILE_NAME =  'Dataset de entrenamiento para Leonardo.png'
COMMERCIAL_FILE_NAME =  'Planilla de sueldos.png'
OPERATIONS_FILE_NAME =  'Lista de proveedores.png'

# Nombre de los 4 usuarios a crear
SOFTWARE_ENGINEER_USER = 'software-engineer-user'
FOOD_SCIENCE_USER = 'food-science-user'
COMMERCIAL_USER = 'commercial-user'
OPERATIONS_USER = 'operations-area-user'

# Nombre de las 4 políticas a crear
SOFTWARE_ENGINEER_POLICY =  'software-engineer-policy'
FOOD_SCIENCE_POLICY =  'food-science-policy'
COMMERCIAL_POLICY =  'commercial-policy'
OPERATIONS_POLICY =  'operations-area-policy'

# Instanciamos el cliente IAM de boto3
iam = boto3.client('iam', aws_access_key_id=AWS_ACCESS_KEY_ID, aws_secret_access_key=AWS_SECRET_ACCESS_KEY)

# Instanciamos el cliente S3 de boto3
s3 = boto3.client('s3', aws_access_key_id=AWS_ACCESS_KEY_ID, aws_secret_access_key=AWS_SECRET_ACCESS_KEY)

"""### Crear _buckets_ en S3

La función recibe un `string` con el nombre del _bucket_.
"""

def create_bucket(bucket_name):
  try:
    s3.create_bucket(Bucket=bucket_name)
  except ClientError as e:
    logging.error(e)
    return False
  return True

"""### Listar buckets en S3

La función imprime el nombre de los _buckets_ existentes en la cuenta.
"""

def list_buckets():
  response = s3.list_buckets()
  print('Existing buckets:')
  for bucket in response['Buckets']:
    print(f'{bucket["Name"]}')

"""### Subir un archivo a un _bucket_

La función recibe el nombre del archivo a subir, el nombre del _bucket_ y el nombre con el que se almacenará el archivo. Los 3 argumentos son del tipo `string`. Si no especificas el nombre con que el que se guardará el archivo, se usara el mismo nombre de este.
"""

def upload_file(file_name, bucket, object_name=None):
  if object_name is None:
    object_name = file_name
  try:
    response = s3.upload_file(file_name, bucket, object_name)
  except ClientError as e:
    logging.error(e)
    return False
  return True

"""### Eliminar un objeto de un _bucket_

Para eliminar un objeto dentro de un _bucket_, debes entregarle a la función dos argumentos del tipo `string`: el primero representa el nombre del *bucket*, mientras el segundo representa el nombre del archivo.
"""

def delete_bucket_object(bucket_name, object_name):
  try:
    s3.delete_object(Bucket=bucket_name, Key=object_name)
  except ClientError as e:
    logging.error(e)
    return False
  return True

"""### Eliminar un _bucket_

Para eliminar un _bucket_, debes entregarle a la función un `string` con el nombre del mismo.
"""

def delete_bucket(bucket_name):
  try:
    s3.delete_bucket(Bucket=bucket_name)
  except ClientError as e:
    logging.error(e)
    return False
  return True

"""### Crear un usuario

Recibe un `string` con el nombre del usuario.
"""

def create_user(user_name):
  try:
    response = iam.create_user(UserName=user_name)
    print(response)
  except ClientError as e:
    logging.error(e)
    return False
  return True

"""### Crear credenciales de acceso a un usuario

Recibe un `string` con el nombre del usuario y retorna un diccionario con sus credenciales de acceso. Esta función crea una llave de acceso para un usuario, la que **debes** guardar en una variable, ya que esta se pierde posteriormente como medida de seguridad de AWS. Si lo llegas a olvidar, lo más simple es que borres el usuario, le vuelvas a asociar la política correspondiente y finalmente, ejecutes la función para obtener sus credenciales, ya que AWS restringe la cantidad de llaves que le puedes crear a un usuario por esta vía.
"""

def get_user_credentials(user_name):
  try:
    access_key = iam.create_access_key(UserName=user_name)
    credentials = { 'AccessKeyId': access_key['AccessKey']['AccessKeyId'], 'SecretAccessKey': access_key['AccessKey']['SecretAccessKey'] }
    print(credentials)
    return credentials
  except ClientError as e:
    logging.error(e)
    return False

"""### Eliminar credenciales de acceso de un usuario

Esta función recibe dos argumentos: el nombre del usuario (de tipo `string`) y el diccionario de credenciales de acceso de un usuario (retornado por el método anterior).
"""

def delete_user_credentials(user_name, credentials):
  try:
    access_key_id = credentials.get('AccessKeyId', '')
    response = iam.delete_access_key(
        UserName=user_name,
        AccessKeyId=access_key_id
    )
    print(response)
  except ClientError as e:
    logging.error(e)
    return False
  return True

"""### Crear una IAM policy

Una política de IAM es un documento que lista todas las acciones que un usuario puede realizar y los recursos a los cuales estas afectan. Este método recibe dos argumentos: `bucket_name` es un `string` con el nombre del bucket al cual se dará acceso. Además, `policy_name` es un `string` con el nombre de la política. A diferencia de la actividad presencial, aquí no debes crear manualmente el `diccionario` con la política, pues la misma función lo generará.
"""

def create_iam_policy(bucket_name, policy_name):
  policy_dic = {
        "Version": "2012-10-17",
        "Statement": [
            {
                "Effect": "Allow",
                "Action": [
                    "s3:GetObject",
                    "s3:ListBucket",
                ],
                "Resource": f'arn:aws:s3:::{bucket_name}',
            }
        ]
    }
  try:
    response = iam.create_policy(
        PolicyName=policy_name,
        PolicyDocument=json.dumps(policy_dic)
    )
    print(f'Arn de política {policy_name}: {response["Policy"]["Arn"]}')
  except ClientError as e:
    logging.error(e)
    return False
  return response['Policy']['Arn']

"""Este método imprime el Arn de la política, el cual deberas usar más adelante. Esta será de la siguiente manera:

```
Arn: 'arn:aws:iam::xxxx:policy/test'
```

### Asignar una política a un usuario

Este método permite asignar las políticas que creaste a un usuario que también hayas creado. Por lo tanto, le puedes dar permisos a los usuarios que lo posean para acceder a los recursos que la política describe. Recibe dos argumentos: el primero, `policy_arn`, es un `string` correspondiente al *Amazon Resource Name* de la política creada, la que es parte de la respuesta entregada por el método anterior (por lo que debes revisarla para poder ejecutar esta función). El `user_name` es el `string` del nombre del usuario que creaste al que le asociarás la política mencionada.
"""

def attach_user_policy(policy_arn, user_name):
  try:
    response = iam.attach_user_policy(
        UserName=user_name,
        PolicyArn=policy_arn
    )
    print(response)
  except ClientError as e:
    logging.error(e)
    return False
  return True

"""### Desasociar políticas

La siguiente función te permite desasociar una política que ya hayas vinculado a un usuario. Recibe un `string` con el nombre de usuario y otro con el arn de la política.
"""

def detach_user_policy(user_name, policy_arn):
  try:
    response = iam.detach_user_policy(
        UserName=user_name,
        PolicyArn=policy_arn
    )
    print(response)
  except ClientError as e:
    logging.error(e)
    return False
  return True

"""### Eliminar un usuario

Para eliminar un usuario debes entregarle a la función un `string` con el nombre del usuario a borrar.
"""

def delete_user(user_name):
  try:
    response = iam.delete_user(
        UserName=user_name
    )
    print(response)
  except ClientError as e:
    logging.error(e)
    return False
  return True

"""### Eliminar una política

Para eliminar una política, debes entregarle a la función un `string` con el ARN de la política a borrar.
"""

def delete_policy(policy_arn):
  try:
    response = iam.delete_policy(
        PolicyArn=policy_arn
    )
    print(response)
  except ClientError as e:
    logging.error(e)
    return False
  return True

"""## DESARROLLO

### PASO 1 - Crear _buckets_
"""

# Crea 4 buckets, uno para cada área de la compañía.
# Estas funciones las debes ejecutar solo una vez, ya que en otro caso
# arrojarán error por nombre duplicado.
create_bucket(SOFTWARE_ENGINEER_BUCKET_NAME)

create_bucket(FOOD_SCIENCE_BUCKET_NAME)

create_bucket(COMMERCIAL_BUCKET_NAME)

create_bucket(OPERATIONS_BUCKET_NAME)

# Listamos los buckets para ver si se crearon correctamente.
# Esto imprimirá todos tus buckets, no solo los creados anteriormente.
list_buckets()

"""### PASO 2 - Subir archivos a los distintos _buckets_"""

# Primero debemos descargar las imágenes en Google Colab.
# Para el correcto desarrollo de la actividad, debes subir solo 1 archivo a
# cada bucket.
import os
import urllib.request

urllib.request.urlretrieve(SOFTWARE_ENGINEER_FILE_LINK, SOFTWARE_ENGINEER_FILE_NAME)

urllib.request.urlretrieve(FOOD_SCIENCE_FILE_LINK, FOOD_SCIENCE_FILE_NAME)

urllib.request.urlretrieve(COMMERCIAL_FILE_LINK, COMMERCIAL_FILE_NAME)

urllib.request.urlretrieve(OPERATIONS_FILE_LINK, OPERATIONS_FILE_NAME)

# Subimos archivo correspondiente al área de software
upload_file(SOFTWARE_ENGINEER_FILE_NAME, SOFTWARE_ENGINEER_BUCKET_NAME)

# Subimos archivo correspondiente al área de ciencia de los alimentos
upload_file(FOOD_SCIENCE_FILE_NAME, FOOD_SCIENCE_BUCKET_NAME)

# Subimos archivo correspondiente al área comercial
upload_file(COMMERCIAL_FILE_NAME, COMMERCIAL_BUCKET_NAME)

# Subimos archivo correspondiente al área de operaciones
upload_file(OPERATIONS_FILE_NAME, OPERATIONS_BUCKET_NAME)

"""### PASO 3 - Creación de usuarios"""

# Creamos un usuario para cada área
# Esta función la debes ejecutar solo una vez para cada usuario, ya que en otro
# caso arrojarán error por nombre duplicado.
create_user(SOFTWARE_ENGINEER_USER)

create_user(FOOD_SCIENCE_USER)

create_user(COMMERCIAL_USER)

create_user(OPERATIONS_USER)

"""### PASO 4 - Creación de políticas"""

# Crea 4 políticas, una para cada área de la compañía.
# Esta función la debes ejecutar solo una vez para cada política
SOFTWARE_ENGINEER_POLICY_ARN = create_iam_policy(SOFTWARE_ENGINEER_BUCKET_NAME, SOFTWARE_ENGINEER_POLICY)

FOOD_SCIENCE_POLICY_ARN = create_iam_policy(FOOD_SCIENCE_BUCKET_NAME, FOOD_SCIENCE_POLICY)

COMMERCIAL_POLICY_ARN = create_iam_policy(COMMERCIAL_BUCKET_NAME, COMMERCIAL_POLICY)

OPERATIONS_POLICY_ARN = create_iam_policy(OPERATIONS_BUCKET_NAME, OPERATIONS_POLICY)

"""### PASO 5 - Asociar políticas a usuarios"""

# Para cada uno de los usuarios creados en el paso 3 le asociamos su respectiva política creada en el paso anterior.
attach_user_policy(SOFTWARE_ENGINEER_POLICY_ARN, SOFTWARE_ENGINEER_USER)

attach_user_policy(FOOD_SCIENCE_POLICY_ARN, FOOD_SCIENCE_USER)

attach_user_policy(COMMERCIAL_POLICY_ARN, COMMERCIAL_USER)

attach_user_policy(OPERATIONS_POLICY_ARN, OPERATIONS_USER)

"""### PASO 6 - Prueba tu código

Para probar el código, haremos uso de la función `get_user_credentials`, lo que nos entregará llaves de acceso por usuario. Estas serán utilizadas para poder consultar los objetos dentro de los *bucket*.
"""

# Almacenamos las credenciales de cada uno de los usuarios. Adicionalmente,
# obtenemos la llave de acceso.
SOFTWARE_ENGINEER_USER_CREDENTIALS = get_user_credentials(SOFTWARE_ENGINEER_USER)

FOOD_SCIENCE_USER_CREDENTIALS = get_user_credentials(FOOD_SCIENCE_USER)

COMMERCIAL_USER_CREDENTIALS = get_user_credentials(COMMERCIAL_USER)

OPERATIONS_USER_CREDENTIALS = get_user_credentials(OPERATIONS_USER)

"""A continuación, se prueba tu código con la función `print_documents_from_bucket`, la que imprime el nombre de los archivos a los que un determinado usuario tiene acceso dentro de un *bucket*. La función recibe tres parámetros del tipo `string`: nombre de usuario, nombre del *bucket* y nombre del archivo. Además, retorna `True` si es que esta correcto el *output* o `False` en caso contrario."""

from boto3.session import Session

def print_documents_from_bucket(credentials, bucket_name, file_name):
  try:
    session = Session(
        aws_access_key_id=credentials['AccessKeyId'],
        aws_secret_access_key=credentials['SecretAccessKey']
    )
    s3_user = session.resource('s3')

    # Imprimimos el nombre de los archivos existentes en el bucket para el rol especificado
    objects = list(s3_user.Bucket(bucket_name).objects.all())
    objects_count = 0
    for obj in objects:
      filename = obj.key.split('/')[-1]
      print(filename)

    if len(objects) == 1 and objects[0].key.split('/')[-1] == file_name:
      return True
    else:
      return False
  except ClientError as e:
    logging.error(e)
    return False

# Documentos asociados al área de Ingeniería de Software
# Debería imprimir "Funcionalidades a implementar.png"
# Solo las personas con la política del área de Ingeniería de Software deberían poder acceder
print_documents_from_bucket(SOFTWARE_ENGINEER_USER_CREDENTIALS, SOFTWARE_ENGINEER_BUCKET_NAME, SOFTWARE_ENGINEER_FILE_NAME)

# Las personas del área de Ciencia de los alimentos no deberían poder acceder
print_documents_from_bucket(FOOD_SCIENCE_USER_CREDENTIALS, SOFTWARE_ENGINEER_BUCKET_NAME, SOFTWARE_ENGINEER_FILE_NAME)

# Las personas del área de Comercial no deberían poder acceder
print_documents_from_bucket(COMMERCIAL_USER_CREDENTIALS, SOFTWARE_ENGINEER_BUCKET_NAME, SOFTWARE_ENGINEER_FILE_NAME)

# Las personas del área de Operaciones no deberían poder acceder
print_documents_from_bucket(OPERATIONS_USER_CREDENTIALS, SOFTWARE_ENGINEER_BUCKET_NAME, SOFTWARE_ENGINEER_FILE_NAME)

# Documentos asociados al área de Ciencia de los alimentos
# Debería imprimir "Dataset de entrenamiento para Leonardo.png"
# Solo las personas con la política del área de Ciencia de los alimentos deberían poder acceder
print_documents_from_bucket(FOOD_SCIENCE_USER_CREDENTIALS, FOOD_SCIENCE_BUCKET_NAME, FOOD_SCIENCE_FILE_NAME)

# Las personas del área de Ingeniería de Software no deberían poder acceder
print_documents_from_bucket(SOFTWARE_ENGINEER_USER_CREDENTIALS, FOOD_SCIENCE_BUCKET_NAME, FOOD_SCIENCE_FILE_NAME)

# Las personas del área de Comercial no deberían poder acceder
print_documents_from_bucket(COMMERCIAL_USER_CREDENTIALS, FOOD_SCIENCE_BUCKET_NAME, FOOD_SCIENCE_FILE_NAME)

# Las personas del área de Operaciones no deberían poder acceder
print_documents_from_bucket(OPERATIONS_USER_CREDENTIALS, FOOD_SCIENCE_BUCKET_NAME, FOOD_SCIENCE_FILE_NAME)

# Documentos asociados al área de Comercial
# Debería imprimir "Planilla de sueldos.png"
# Solo las personas con la política del área de Comercial deberían poder acceder
print_documents_from_bucket(COMMERCIAL_USER_CREDENTIALS, COMMERCIAL_BUCKET_NAME, COMMERCIAL_FILE_NAME)

# Las personas del área de Ingeniería de Software no deberían poder acceder
print_documents_from_bucket(SOFTWARE_ENGINEER_USER_CREDENTIALS, COMMERCIAL_BUCKET_NAME, COMMERCIAL_FILE_NAME)

# Las personas del área de Ciencia de los alimentos no deberían poder acceder
print_documents_from_bucket(FOOD_SCIENCE_USER_CREDENTIALS, COMMERCIAL_BUCKET_NAME, COMMERCIAL_FILE_NAME)

# Las personas del área de Operaciones no deberían poder acceder.
print_documents_from_bucket(OPERATIONS_USER_CREDENTIALS, COMMERCIAL_BUCKET_NAME, COMMERCIAL_FILE_NAME)

# Documentos asociados al área de Operaciones
# Debería imprimir "Lista de proveedores.png"
# Solo las personas con la política del área de Operacions deberían poder acceder.
print_documents_from_bucket(OPERATIONS_USER_CREDENTIALS, OPERATIONS_BUCKET_NAME, OPERATIONS_FILE_NAME)

# Las personas del área de Ingeniería de Software no deberían poder acceder.
print_documents_from_bucket(SOFTWARE_ENGINEER_USER_CREDENTIALS, OPERATIONS_BUCKET_NAME, OPERATIONS_FILE_NAME)

# Las personas del área de Ciencia de los alimentos no deberían poder acceder.
print_documents_from_bucket(FOOD_SCIENCE_USER_CREDENTIALS, OPERATIONS_BUCKET_NAME, OPERATIONS_FILE_NAME)

# Las personas del área de Comercial no deberían poder acceder.
print_documents_from_bucket(COMMERCIAL_USER_CREDENTIALS, OPERATIONS_BUCKET_NAME, OPERATIONS_FILE_NAME)

"""### PASO 7 - Limpieza

Como medida de seguridad, eliminaremos todas las instancias creadas en el siguiente orden:

1. Desasociar políticas de los usuarios.
2. Eliminar políticas.
3. Eliminar llaves de acceso de usuarios.
4. Eliminar usuarios.
5. Eliminar archivos dentro de los *buckets*.
6. Eliminar *buckets*.
"""

# Desasociación de políticas.
detach_user_policy(SOFTWARE_ENGINEER_USER, SOFTWARE_ENGINEER_POLICY_ARN)
detach_user_policy(FOOD_SCIENCE_USER, FOOD_SCIENCE_POLICY_ARN)
detach_user_policy(COMMERCIAL_USER, COMMERCIAL_POLICY_ARN)
detach_user_policy(OPERATIONS_USER, OPERATIONS_POLICY_ARN)

# Eliminación de políticas.
delete_policy(SOFTWARE_ENGINEER_POLICY_ARN)
delete_policy(FOOD_SCIENCE_POLICY_ARN)
delete_policy(COMMERCIAL_POLICY_ARN)
delete_policy(OPERATIONS_POLICY_ARN)

# Eliminación de llaves de acceso.
delete_user_credentials(SOFTWARE_ENGINEER_USER, SOFTWARE_ENGINEER_USER_CREDENTIALS)
delete_user_credentials(FOOD_SCIENCE_USER, FOOD_SCIENCE_USER_CREDENTIALS)
delete_user_credentials(COMMERCIAL_USER, COMMERCIAL_USER_CREDENTIALS)
delete_user_credentials(OPERATIONS_USER, OPERATIONS_USER_CREDENTIALS)

# Eliminación de usuarios.
delete_user(SOFTWARE_ENGINEER_USER)
delete_user(FOOD_SCIENCE_USER)
delete_user(COMMERCIAL_USER)
delete_user(OPERATIONS_USER)

# Eliminación de objetos dentro de los buckets.
delete_bucket_object(SOFTWARE_ENGINEER_BUCKET_NAME, SOFTWARE_ENGINEER_FILE_NAME)
delete_bucket_object(FOOD_SCIENCE_BUCKET_NAME, FOOD_SCIENCE_FILE_NAME)
delete_bucket_object(COMMERCIAL_BUCKET_NAME, COMMERCIAL_FILE_NAME)
delete_bucket_object(OPERATIONS_BUCKET_NAME, OPERATIONS_FILE_NAME)

# Eliminación de buckets.
delete_bucket(SOFTWARE_ENGINEER_BUCKET_NAME)
delete_bucket(FOOD_SCIENCE_BUCKET_NAME)
delete_bucket(COMMERCIAL_BUCKET_NAME)
delete_bucket(OPERATIONS_BUCKET_NAME)

"""## ¿CON GANAS DE MÁS?

Te proponemos los siguientes ejercicios adicionales si quieres practicar más con lo que has aprendido de este contenido:

1. Crea un nuevo usuario "supervisor" y una política que le entregue acceso a todos los *buckets* de la empresa YesIndustry.
2. Crea un nuevo usuario "supervisor-desarrollo" y una política que le entregue acceso **solo** a los *buckets* de las áreas de "desarrollo de software" y "ciencia de los alimentos".
3. Agrega la etiqueta de clave "area" y valor "desarrollo" al *bucket* del área de desarrollo de software. Luego, crea dos usuarios "practicante-1" y "practicante-2". Haz que el primero posea una etiqueta de clave "area" y valor "desarrollo" y que el segundo tenga una etiqueta de clave "area" y valor "comercial". Luego, crea una política que de acceso al *bucket* de área de desarrollo si, y solo si el usuario que trata de acceder a dicho *bucket* tiene la etiqueta "area" del mismo valor. Se dejan a continuación los recursos necesarios para completar dicha tarea: [asignación de etiquetas a *buckets*](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/s3.html#S3.BucketTagging.put); [asignación de etiquetas a usuarios IAM](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/iam.html#IAM.Client.tag_user); [condición de permisos según valor de etiqueta](https://docs.aws.amazon.com/es_es/IAM/latest/UserGuide/access_iam-tags.html). Como *tip*, en la diapositiva 25 de la clase hay un ejemplo preciso para lo solicitado.

Puedes hacer uso de las funciones anteriores para probar que tus implementaciones funcionan. Si lo logras, ¡envíame tus resultados a glcontreras@uc.cl!
"""